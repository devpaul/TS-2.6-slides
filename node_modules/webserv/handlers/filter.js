"use strict";
const url_1 = require("url");
const proxies_1 = require("../util/proxies");
/**
 * Apply a filter that will execute the handler if the supplied filter matches. If a string
 * or a RegExp are supplied they will be compared against the incoming URL. A filter function is
 * passed the incoming request allowing for more complex filtering.
 *
 * @param handler the handler to be executed
 * @param filter the filter that must pass for the handler to be executed
 */
function filter(handler, filter) {
    let filterFunction = createFilter(filter);
    return function (request, response) {
        if (!filterFunction(request)) {
            return Promise.resolve();
        }
        return handler(request, response);
    };
}
exports.filter = filter;
/**
 * Wrap a Handler in a Proxy that filters #handle()
 *
 * @param handler the Handler to be proxied
 * @param f the filter that must pass for the handler to be executed
 * @return {Handler} a proxied version of the handler
 */
function proxy(handler, f) {
    const filterFunction = createFilter(f);
    return proxies_1.overrideWrapper(handler, {
        handle: filter(handler.handle.bind(handler), filterFunction)
    });
}
exports.proxy = proxy;
/**
 * Create a filter that matches on the request's http method
 *
 * @param method the http method to match
 */
function method(method) {
    return filterObject({
        method: method.toLowerCase()
    });
}
exports.method = method;
/**
 * This is an OR operator for filters. It combines a list of filters together into a single filter function so
 * the first condition that passes will pass the entire filter
 *
 * @param filters a series of filters to be combined
 */
function first(...filters) {
    const filterFunctions = filters.map(createFilter);
    return function (request) {
        return filterFunctions.some(function (filter) {
            return filter(request);
        });
    };
}
exports.first = first;
/**
 * This is an AND operator for filters. It combines a list of filters together into a single filter function and
 * requires that all conditions pass to pass the filter
 *
 * @param filters a series of filters to be combined
 */
function every(...filters) {
    const filterFunctions = filters.map(createFilter);
    return function (request) {
        return filterFunctions.every(function (filter) {
            return filter(request);
        });
    };
}
exports.every = every;
/**
 * Create a filter function from any of the valid filter types
 */
function createFilter(filter) {
    if (typeof filter === 'string') {
        return filterStringRoute(filter);
    }
    else if (filter instanceof RegExp) {
        return filterRegexRoute(filter);
    }
    else if (typeof filter === 'function') {
        return filter;
    }
    else if (typeof filter === 'object' && filter) {
        return filterObject(filter);
    }
    else {
        throw new Error('invalid filter');
    }
}
exports.createFilter = createFilter;
/**
 * create a filter function from a string match
 */
function filterStringRoute(match) {
    return function (request) {
        // TODO make this more robust
        const url = url_1.parse(request.url);
        return url.pathname.indexOf(match) === 0;
    };
}
/**
 * create a filter function from a regular expression
 */
function filterRegexRoute(match) {
    return function (request) {
        const url = url_1.parse(request.url);
        return match.test(url.pathname);
    };
}
/**
 * create a filter function from an object whose keys will be compared against the incoming message
 */
function filterObject(match) {
    return function (request) {
        // TODO add deep matching for non-primitives
        for (let key in match) {
            if (match[key] !== request[key]) {
                return false;
            }
        }
        return true;
    };
}
//# sourceMappingURL=filter.js.map